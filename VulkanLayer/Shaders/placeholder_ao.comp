#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0, rgba16f) uniform writeonly image2D uOutputImage;
layout(binding = 1) uniform sampler2D uDepthTexture;
layout(binding = 2) uniform sampler2D uColorTexture;
layout(binding = 3) uniform sampler2D uNormalTexture;

const vec2 kSampleKernel[12] = vec2[](
    vec2(1.0, 0.0),
    vec2(-1.0, 0.0),
    vec2(0.0, 1.0),
    vec2(0.0, -1.0),
    vec2(1.0, 1.0),
    vec2(-1.0, 1.0),
    vec2(1.0, -1.0),
    vec2(-1.0, -1.0),
    vec2(2.0, 0.5),
    vec2(-2.0, -0.5),
    vec2(0.5, 2.0),
    vec2(-0.5, -2.0)
);

vec3 DecodeNormal(vec3 encoded)
{
    vec3 n = normalize(encoded * 2.0 - 1.0);
    return n;
}

void main()
{
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 dims = imageSize(uOutputImage);
    if (coord.x >= dims.x || coord.y >= dims.y)
    {
        return;
    }

    vec2 resolution = vec2(dims);
    vec2 uv = (vec2(coord) + 0.5) / resolution;

    vec4 baseColor = textureLod(uColorTexture, uv, 0.0);
    float centerDepth = textureLod(uDepthTexture, uv, 0.0).r;
    if (centerDepth <= 0.0)
    {
        imageStore(uOutputImage, coord, vec4(baseColor.rgb, 1.0));
        return;
    }

    vec3 centerNormal = DecodeNormal(textureLod(uNormalTexture, uv, 0.0).xyz);

    const float radiusPixels = 6.0;
    const float depthScale = 80.0;
    const float bias = 0.0015;
    const float normalWeightScale = 0.85;

    vec2 pixelSize = 1.0 / resolution;
    float occlusion = 0.0;
    float weightSum = 0.0;

    for (int i = 0; i < 12; ++i)
    {
        vec2 offset = kSampleKernel[i] * radiusPixels * pixelSize;
        vec2 sampleUv = clamp(uv + offset, vec2(0.0), vec2(1.0));

        float sampleDepth = textureLod(uDepthTexture, sampleUv, 0.0).r;
        vec3 sampleNormal = DecodeNormal(textureLod(uNormalTexture, sampleUv, 0.0).xyz);

        float depthDifference = sampleDepth - centerDepth;
        float depthContribution = clamp(abs(depthDifference) * depthScale - bias, 0.0, 1.5);
        float normalSimilarity = clamp(dot(centerNormal, sampleNormal), 0.0, 1.0);
        float normalContribution = 1.0 - pow(normalSimilarity, 2.0);

        float distanceWeight = 1.0 - clamp(length(offset) * 0.5, 0.0, 1.0);
        float contribution = depthContribution * mix(1.0, normalContribution, normalWeightScale) * distanceWeight;

        occlusion += contribution;
        weightSum += distanceWeight;
    }

    float ao = 1.0;
    if (weightSum > 0.0)
    {
        float normalizedOcclusion = clamp(occlusion / weightSum, 0.0, 1.5);
        ao = clamp(1.0 - normalizedOcclusion * 0.75, 0.0, 1.0);
    }

    vec3 shadedColor = baseColor.rgb * mix(1.0, ao, 0.85);
    imageStore(uOutputImage, coord, vec4(shadedColor, 1.0));
}
