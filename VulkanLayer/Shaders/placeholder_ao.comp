#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0, rgba16f) uniform writeonly image2D uOutputImage;
layout(binding = 1) uniform sampler2D uDepthTexture;

const vec2 kSampleKernel[8] = vec2[](
    vec2(1.0, 0.0),
    vec2(-1.0, 0.0),
    vec2(0.0, 1.0),
    vec2(0.0, -1.0),
    vec2(1.0, 1.0),
    vec2(-1.0, 1.0),
    vec2(1.0, -1.0),
    vec2(-1.0, -1.0)
);

void main()
{
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 dims = imageSize(uOutputImage);
    if (coord.x >= dims.x || coord.y >= dims.y)
    {
        return;
    }

    vec2 resolution = vec2(dims);
    vec2 uv = (vec2(coord) + 0.5) / resolution;

    float centerDepth = textureLod(uDepthTexture, uv, 0.0).r;
    if (centerDepth <= 0.0)
    {
        imageStore(uOutputImage, coord, vec4(1.0));
        return;
    }

    const float radiusPixels = 4.0;
    const float bias = 0.0025;
    const float depthScale = 60.0;
    const float rangeScale = 80.0;

    vec2 pixelSize = 1.0 / resolution;
    float occlusion = 0.0;

    for (int i = 0; i < 8; ++i)
    {
        vec2 offset = kSampleKernel[i] * radiusPixels * pixelSize;
        vec2 sampleUv = clamp(uv + offset, vec2(0.0), vec2(1.0));
        float sampleDepth = textureLod(uDepthTexture, sampleUv, 0.0).r;

        float depthDifference = centerDepth - sampleDepth - bias;
        float contribution = clamp(depthDifference * depthScale, 0.0, 1.0);
        float rangeWeight = clamp(1.0 - abs(centerDepth - sampleDepth) * rangeScale, 0.0, 1.0);
        occlusion += contribution * rangeWeight;
    }

    occlusion = clamp(occlusion / 8.0, 0.0, 1.0);
    float ao = clamp(1.0 - occlusion, 0.0, 1.0);
    ao = 0.2 + 0.8 * ao;

    imageStore(uOutputImage, coord, vec4(vec3(ao), 1.0));
}
